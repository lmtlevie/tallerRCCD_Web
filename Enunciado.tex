\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{graphicx}

\geometry{margin=2.5cm}

% Configuración de colores
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Estilo de código
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Configuración de títulos
\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection}{1em}{}

% Encabezado y pie de página
\pagestyle{fancy}
\fancyhf{}
\lhead{Redes de Comunicaciones y Cómputo Distribuido}
\rhead{1er Cuatrimestre 2026}
\cfoot{\thepage}

\begin{document}

\begin{center}
    {\Large \textbf{Redes de Comunicaciones y Cómputo Distribuido}}\\[0.3cm]
    {\large 1er Cuatrimestre 2026}\\[1cm]
    
    {\Huge \textbf{Taller - Protocolos HTTP y WebSocket}}\\[0.5cm]
    
    \textbf{LEER EL ENUNCIADO COMPLETO ANTES DE ARRANCAR.}\\[0.5cm]
    
\end{center}

\section*{Objetivo}

Este taller tiene como objetivo comprender cómo funcionan los protocolos de nivel de aplicación. Se enfoca en entender la construcción de requests y responses, el intercambio de información entre cliente y servidor y la diferencia entre protocolos stateless (HTTP) y stateful (WebSocket).

\section*{Metodología de Trabajo}

Para completar cada ejercicio o subconsigna, el alumno debe crear un archivo con el request HTTP/WebSocket dentro de la carpeta \texttt{requests/}, luego implementar el código correspondiente en los archivos indicados, y finalmente ejecutar el request con netcat para validar que la implementación funciona correctamente.

En cada ejercicio que requiera modificar el servidor, se debe actualizar principalmente la función \texttt{handle\_client()} en \texttt{http\_server.py} o \texttt{websocket\_server.py}, según corresponda. Después de realizar cambios en el código del servidor, es necesario detener el servidor (si está corriendo) y levantarlo nuevamente para que los cambios surtan efecto.

Para visualizar los resultados de la implementación, se puede usar la función \texttt{print()} en el código del servidor para ver información en la terminal donde corre el servidor, o incluir información en el response HTTP para observarla desde el cliente con netcat.

\section*{Herramientas}

Netcat (comando \texttt{nc}) es una herramienta que permite enviar datos raw por TCP. Se utiliza para enviar requests HTTP manualmente y observar las respuestas. La sintaxis básica es:

\begin{lstlisting}[language=bash]
cat archivo.http | nc localhost 8080
\end{lstlisting}

Este comando lee el archivo y lo envía byte por byte al servidor en localhost puerto 8080, mostrando la respuesta exacta que el servidor devuelve.

\section{Ejercicio 1: Protocolo HTTP}

Trabajar sobre la carpeta ej1

En este ejercicio se trabajará principalmente con dos archivos: \texttt{http\_parser.py} para las funciones de parsing y construcción de responses, y \texttt{http\_server.py} para la lógica del servidor. La función principal que se modificará en el servidor es \texttt{handle\_client()}, que recibe las conexiones de los clientes. Después de cada modificación en el código, se debe reiniciar el servidor ejecutando nuevamente \texttt{python http\_server.py} en una terminal, y en otra terminal ejecutar los requests con netcat para validar los cambios.

\subsection{Ejercicio 1.1}

Completar la función \texttt{parse\_request\_line()} en el archivo \texttt{http\_parser.py}. Esta función debe separar la primera línea de un HTTP request en sus tres componentes: método, path y versión del protocolo. La función recibe como entrada un string como \texttt{"GET /index.html HTTP/1.1"} y debe retornar un diccionario con las keys \texttt{"method"}, \texttt{"path"} y \texttt{"version"}.

Para completar este ejercicio, crear un archivo \texttt{requests/01\_parse\_test.http} con un request HTTP simple y ejecutarlo con netcat para verificar que el parser funciona correctamente.

\subsection{Ejercicio 1.2}

Completar la función \texttt{build\_response()} en el archivo \texttt{http\_parser.py}. Esta función formatea respuestas HTTP correctamente según el estándar. Recibe como parámetros el código de estado (200, 404, etc.), el contenido de la respuesta en bytes, y opcionalmente un diccionario con headers (donde cada key es el nombre del header y cada value es su valor). Debe construir un response HTTP con el siguiente formato:

\begin{lstlisting}
HTTP/1.1 CODIGO MENSAJE\r\n
[headers, uno por línea]
\r\n
body
\end{lstlisting}

Utilizar el diccionario \texttt{STATUS\_MESSAGES} para obtener el mensaje correspondiente al código de estado. Si se proporciona el header \texttt{Content-Type} en el diccionario de headers, incluirlo en la respuesta.


\subsection{Ejercicio 1.3}

Para completar este ejercicio, primero crear el archivo \texttt{requests/01\_get.http} que solicite el recurso \texttt{/index.html}. Un GET request tiene la siguiente estructura:

\begin{lstlisting}
METODO RECURSO VERSION
[linea vacia]
\end{lstlisting}

Luego, en el archivo \texttt{http\_server.py}, completar las funciones \texttt{handle\_client()} y \texttt{handle\_get()} para manejar requests GET. En \texttt{handle\_client()} usar \texttt{parse\_request\_line()} y pasar el diccionario resultante a \texttt{handle\_get()}. La función \texttt{handle\_get()} debe leer el archivo desde \texttt{resources/} y retornarlo con \texttt{build\_response()}.

Finalmente, para validar que el ejercicio está completo, levantar el servidor con \texttt{python http\_server.py} y en otra terminal ejecutar el request creado:

\begin{lstlisting}[language=bash]
cat requests/01_get.http | nc localhost 8080
\end{lstlisting}


\subsection{Ejercicio 1.4}

Completar la función \texttt{parse\_headers()} en el archivo \texttt{http\_parser.py}. Esta función debe parsear las líneas de headers de un HTTP request. Los headers tienen el formato \texttt{"Key: Value"} y deben retornarse en un diccionario donde las keys están en minúsculas. La función recibe una lista de strings con las líneas de headers y retorna un diccionario.

Para completar este ejercicio, crear un archivo \texttt{requests/02\_headers.http} con un request que incluya múltiples headers como Host, User-Agent, Accept y Connection, y ejecutarlo con netcat para verificar que el parser funciona correctamente.

\subsection{Ejercicio 1.5}

Para completar este ejercicio, primero crear el archivo \texttt{requests/03\_get\_json.http} que solicite el recurso \texttt{/users.json} con headers, incluyendo el header \texttt{Accept: application/json}. Un GET request con headers tiene la siguiente estructura:

\begin{lstlisting}
GET /users.json HTTP/1.1
Host: localhost:8080
Accept: application/json
\end{lstlisting}



Finalmente, para validar que el ejercicio está completo, ejecutar el request creado con netcat:

\begin{lstlisting}[language=bash]
cat requests/03_get_json.http | nc localhost 8080
\end{lstlisting}

\subsection{Ejercicio 1.6}

Completar la función \texttt{parse\_request()} en el archivo \texttt{http\_parser.py} para que también parse el body del request. La línea vacía separa los headers del body. Si existe el header \texttt{Content-Length}, leer exactamente esa cantidad de bytes como body. La función debe retornar un diccionario con las keys \texttt{method}, \texttt{path}, \texttt{version}, \texttt{headers} y \texttt{body}.

Para completar este ejercicio, crear un archivo \texttt{requests/04\_parse\_body.http} con un request que incluya headers y body, y ejecutarlo con netcat para verificar que el parser funciona correctamente.
\subsection{Ejercicio 1.7}

Para completar este ejercicio, primero crear el archivo \texttt{requests/05\_post.http} con el siguiente contenido:

\begin{lstlisting}
POST /users HTTP/1.1
Host: localhost:8080
Content-Type: application/json
Content-Length: 20

{"name": "Charlie"}
\end{lstlisting}

El header \texttt{Content-Length} indica el número de bytes del body. En este ejemplo, el body \texttt{"\{name": "Charlie"\}"} tiene 20 bytes. Luego, en el archivo \texttt{http\_server.py}, completar la función \texttt{handle\_post()} para procesar requests POST y retornar código 201. Actualizar el ruteo en \texttt{handle\_client()} para manejar el método POST. La función \texttt{handle\_post()} recibirá un diccionario con las keys \texttt{method}, \texttt{path}, \texttt{version}, \texttt{headers} y \texttt{body}.

Finalmente, para validar que el ejercicio está completo, ejecutar el request creado con netcat:

\begin{lstlisting}[language=bash]
cat requests/05_post.http | nc localhost 8080
\end{lstlisting}

\subsection{Ejercicio 1.8}

Para completar este ejercicio, primero crear el archivo \texttt{requests/06\_not\_found.http} solicitando un recurso inexistente como \texttt{/noexiste.html}. La implementación anterior ya debe manejar correctamente el error 404.

Finalmente, para validar que el ejercicio está completo, ejecutar el request creado con netcat:

\begin{lstlisting}[language=bash]
cat requests/06_not_found.http | nc localhost 8080
\end{lstlisting}

\section{Ejercicio 2: Protocolo WebSocket}

Trabajar sobre la carpeta ej2

El protocolo WebSocket permite comunicación bidireccional en tiempo real entre cliente y servidor. A diferencia de HTTP que es stateless y requiere un nuevo request para cada respuesta, WebSocket mantiene una conexión abierta que permite que ambas partes envíen datos cuando lo necesiten.

El establecimiento de una conexión WebSocket comienza con un handshake que utiliza HTTP. El cliente envía un request HTTP normal pero con headers especiales que indican el deseo de hacer upgrade a WebSocket. El servidor debe verificar estos headers y responder con un código de estado 101 (Switching Protocols) para confirmar que acepta el upgrade.

\subsection{Ejercicio 2.1}

Para completar este ejercicio, primero crear el archivo \texttt{requests/handshake.http} con un HTTP request de upgrade WebSocket. El request es un GET normal con headers especiales: \texttt{Upgrade: websocket}, \texttt{Connection: Upgrade}, \texttt{Sec-WebSocket-Key} (valor aleatorio de 16 bytes en Base64), y \texttt{Sec-WebSocket-Version: 13}. El request debe tener la siguiente estructura:

\begin{lstlisting}
GET / HTTP/1.1
Host: localhost:8080
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

\end{lstlisting}

Para este ejercicio se puede usar el valor de ejemplo \texttt{dGhlIHNhbXBsZSBub25jZQ==} o generar uno nuevo.

El servidor debe calcular \texttt{Sec-WebSocket-Accept} para probar que entiende el protocolo: tomar el \texttt{Sec-WebSocket-Key} del cliente, concatenarlo con el string mágico \texttt{"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"}, calcular SHA-1, y codificar en Base64.

En el archivo \texttt{websocket\_frame.py}, las funciones \texttt{sha1\_hash()} y \texttt{base64\_encode()} ya están implementadas. Completar la función \texttt{calculate\_accept\_key()} que recibe el \texttt{Sec-WebSocket-Key} como string, lo concatena con el string mágico, calcula SHA-1 usando \texttt{sha1\_hash()}, y codifica en Base64 usando \texttt{base64\_encode()}.

En el archivo \texttt{websocket\_server.py}, completar la función \texttt{handle\_handshake()} para procesar el request de upgrade. La función debe recibir datos del socket, parsear con \texttt{parse\_request()} del Ejercicio 1, verificar que el header \texttt{upgrade} sea \texttt{"websocket"} y que exista \texttt{sec-websocket-key}, calcular el accept key, y construir y enviar un response HTTP con código 101. Para construir la respuesta, usar \texttt{build\_response()} del Ejercicio 1 pasando un diccionario con los headers necesarios para WebSocket (\texttt{Upgrade}, \texttt{Connection} y \texttt{Sec-WebSocket-Accept}) en el parámetro \texttt{headers}. El formato del response es:

\begin{lstlisting}
HTTP/1.1 101 Switching Protocols\r\n
Upgrade: websocket\r\n
Connection: Upgrade\r\n
Sec-WebSocket-Accept: [accept key calculado]\r\n
\r\n
\end{lstlisting}

El código 101 indica que el servidor acepta el upgrade. Cualquier otro código indica que el handshake falló.

Finalmente, para validar que el ejercicio está completo, levantar el servidor con \texttt{python websocket\_server.py} y en otra terminal ejecutar:

\begin{lstlisting}[language=bash]
cat requests/handshake.http | nc localhost 8080
\end{lstlisting}

El servidor debe responder con código 101 y el header \texttt{Sec-WebSocket-Accept} con el valor calculado correctamente.

\subsection{Ejercicio 2.2}

Una vez completado el handshake, la conexión cambia de HTTP a WebSocket y comienza la comunicación mediante frames binarios. A diferencia de HTTP que utiliza texto plano, WebSocket empaqueta todos los mensajes en frames binarios con una estructura específica.

La estructura de un frame WebSocket para payloads menores a 126 bytes se muestra en la siguiente figura:

\begin{center}
\includegraphics[width=0.9\textwidth]{imagenes/images.png}
\end{center}

El primer byte contiene el bit FIN (bit 7) que indica si es el último fragmento, y el opcode (bits 0-3) que define el tipo de frame. Los opcodes importantes son \texttt{0x1} para mensaje de texto y \texttt{0x8} para cerrar conexión. El segundo byte contiene el bit MASK (bit 7) que indica si el payload está enmascarado, y la longitud del payload (bits 0-6). Si MASK es 1, los siguientes 4 bytes son la masking key, y después viene el payload enmascarado. Si MASK es 0, el payload comienza inmediatamente después del segundo byte.

El RFC 6455 requiere que todos los frames del cliente al servidor estén enmascarados usando XOR. La función \texttt{unmask\_payload()} en \texttt{websocket\_frame.py} ya está implementada: para cada byte \texttt{i}, calcula \texttt{j = i \% 4} y hace \texttt{payload[i] XOR masking\_key[j]}.

\subsubsection{Ejercicio 2.2.1}

En el archivo \texttt{websocket\_frame.py}, completar la función \texttt{build\_frame()} que construye un frame para enviar desde el servidor. El servidor nunca enmascara frames (MASK bit = 0). La función \texttt{parse\_frame()} ya está implementada y puede usarse como referencia para entender la estructura de los frames. Construir el primer byte con FIN=1 y el opcode, el segundo byte con MASK=0 y la longitud del payload, y luego agregar el payload codificado en UTF-8. Solo manejar payloads menores a 126 bytes.

\subsubsection{Ejercicio 2.2.2}

En el archivo \texttt{websocket\_server.py}, completar la función \texttt{handle\_messages()} que maneja la comunicación después del handshake exitoso. Ejecutar un loop que reciba datos del socket, parsear el frame con \texttt{parse\_frame()}, y si el opcode es \texttt{0x1} (text), imprimir el mensaje recibido, construir un frame de respuesta con \texttt{build\_frame()}, y enviarlo de vuelta al cliente. Si el opcode es \texttt{0x8} (close) o no hay datos, terminar el loop. Actualizar \texttt{handle\_client()} para que después de un handshake exitoso llame a \texttt{handle\_messages()}.

Finalmente, para validar que el ejercicio está completo, levantar el servidor con \texttt{python websocket\_server.py}, abrir \texttt{client.html} en el navegador, hacer clic en "Conectar", y enviar mensajes. El servidor debe hacer eco de cada mensaje recibido, demostrando la comunicación bidireccional en tiempo real.


\end{document}
